import{ly as M,aU as B,fN as U,lz as A,lA as J,fn as w,lt as N,lB as q,fk as E,aC as g,aJ as K,aD as _,aF as Q}from"./index-Ag4O5CUz.js";import{r as V}from"./dehydratedFeatureComparison-byYkTxmp.js";import{U as W}from"./InteractiveToolBase-ZS0Zg93l.js";import{e as X}from"./SnappingContext-ylT1YTTy.js";function lt({predicate:t=()=>!0,snappingManager:n,snappingContext:e,updatingHandles:s,useZ:o=!0}){const a=new W;if(n==null)return{snappingStep:[O,a],cancelSnapping:O};let l,p=null,i=null,c=null;const d=()=>{p=w(p),n.doneSnapping(),i==null||i.frameTask.remove(),i=null,l=N(l),c=null},m=Y(n,o,a);let f=null,u=null,T=null;return{snappingStep:[r=>{if(!t(r))return r;const{action:y}=r;if(y==="start"){const{info:x}=r,v=j(n.view);if(i=tt(e,r,v),i.context.selfSnappingZ=null,!o&&x!=null){const P=et(e.coordinateHelper,x.handle.component);P!=null&&(i.context.selfSnappingZ={value:P,elevationInfo:e.elevationInfo??M})}}if(i!=null){const{context:x,originalScenePos:v,originalPos:P}=i,{mapEnd:b,mapStart:Z,scenePoints:H}=r,S=F(P,C(b,Z)),z=C(Z,P),R={...r,action:"update"},$=i.context,k=nt(v,H),I=n.update({point:S,scenePoint:k,context:x});if(T=I,G(b,I,z,o),f=S,u=k,y!=="end"){const{frameTask:D}=i;p==null&&(p=new AbortController),c=L=>{s.addPromise(q(m({frameTask:D,event:R,context:$,point:S,scenePoint:k,delta:z,getLastState:()=>({point:f,scenePoint:u,updatePoint:L.forceUpdate?null:T})},p.signal)))},c({forceUpdate:!1}),l==null&&(l=B(()=>n.options.effectiveEnabled,()=>c==null?void 0:c({forceUpdate:!0})))}}return y==="end"&&d(),r},a],cancelSnapping:r=>(d(),r)}}function Y(t,n,e){return E(async({frameTask:s,point:o,scenePoint:a,context:l,event:p,delta:i,getLastState:c},d)=>{const m=await s.schedule(()=>t.snap({point:o,scenePoint:a,context:l,signal:d}),d);if(m.valid){let f=await s.schedule(()=>m.apply(),d);const u=c();u.point!=null&&o!==u.point&&(f=t.update({point:u.point,scenePoint:u.scenePoint,context:l})),u.updatePoint!=null&&V(f,u.updatePoint)||(G(p.mapEnd,f,i,n),e.execute(p))}})}function j(t){return t.type==="3d"?t.resourceController.scheduler.registerTask(U.SNAPPING):A}function tt(t,n,e){return{context:new X({editGeometryOperations:t.editGeometryOperations,elevationInfo:t.elevationInfo,pointer:t.pointer,vertexHandle:n.info!=null?n.info.handle:null,excludeFeature:t.excludeFeature,feature:t.feature,visualizer:t.visualizer}),originalPos:n.snapOrigin!=null?t.coordinateHelper.vectorToDehydratedPoint(n.snapOrigin):n.mapStart,originalScenePos:n.scenePoints!=null?n.scenePoints.sceneStart:null,frameTask:e}}function F(t,[n,e,s]){const o=J(t);return o.x+=n,o.y+=e,o.hasZ&&(o.z+=s),o}function nt(t,n){return t==null||n==null?null:F(t,C(n.sceneEnd,n.sceneStart))}function C(t,n){const e=t.hasZ&&n.hasZ?t.z-n.z:0;return[t.x-n.x,t.y-n.y,e]}function G(t,n,[e,s,o],a){t.x=n.x+e,t.y=n.y+s,a&&t.hasZ&&n.hasZ&&(t.z=n.z+o)}function et(t,n){if(!t.hasZ())return null;const e=n.vertices;let s=null;for(const o of e){const a=t.getZ(o.pos);if(s!=null&&a!=null&&Math.abs(a-s)>1e-6)return null;s==null&&(s=a)}return s}function O(t){return t}let h=class extends K{constructor(t){super(t),this.constrainResult=n=>n,this._snapPoints=null,this._frameTask=null,this._abortController=null,this._stagedPoint=null,this._snap=E(async(n,e,s,o)=>{const a=this._frameTask;if(a==null)return;const l=await a.schedule(()=>e.snap({...n,context:s,signal:o}),o);l.valid&&await a.schedule(()=>{this.stagedPoint=l.apply(),n!==this._snapPoints&&this._snapPoints!=null&&(this.stagedPoint=e.update({...this._snapPoints,context:s}))},o)})}get stagedPoint(){return this._stagedPoint}set stagedPoint(t){this._stagedPoint=this.constrainResult(t)}initialize(){var n,e;const t=this.view.type==="3d"?(e=(n=this.view)==null?void 0:n.resourceController)==null?void 0:e.scheduler:null;this._frameTask=t!=null?t.registerTask(U.SNAPPING):A}destroy(){this._abortController=w(this._abortController),this._frameTask=N(this._frameTask)}update(t,n,e){this._snapPoints=t;const{point:s,scenePoint:o}=t,a=n.update({point:s,scenePoint:o,context:e});return this.stagedPoint=a,a}async snap(t,n,e){const{point:s,scenePoint:o}=t;return this.stagedPoint=n.update({point:s,scenePoint:o,context:e}),this._snapPoints=t,this._abortController==null&&(this._abortController=new AbortController),this._snap(t,n,e,this._abortController.signal)}async resnap(t,n){this._snapPoints!=null&&await this.snap(this._snapPoints,t,n)}abort(){this._abortController=w(this._abortController),this._snapPoints=null}};g([_({constructOnly:!0})],h.prototype,"view",void 0),g([_()],h.prototype,"stagedPoint",null),g([_()],h.prototype,"constrainResult",void 0),g([_()],h.prototype,"_stagedPoint",void 0),h=g([Q("esri.views.interactive.snapping.SnappingOperation")],h);export{lt as f,h as p};
