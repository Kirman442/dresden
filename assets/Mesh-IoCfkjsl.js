import{sQ as Le,cC as je,sR as te,sS as ne,lL as S,aT as d,nG as W,jC as re,fL as w,sT as Xe,sU as Ye,hJ as Me,di as H,dp as le,cz as L,sp as et,sV as tt,bx as ce,hK as nt,fo as rt,l0 as st,aC as g,aD as x,aF as Pe,jN as ot,aW as it,b3 as at,jm as Oe,g0 as ue,rh as Ee,j4 as Q,sW as pe,sX as fe,sY as he,sZ as me,s_ as ge,s$ as de,i4 as ke,fA as xe,p3 as I,oZ as lt,o_ as X,fJ as ct,t0 as we,f8 as N,fK as ze,t1 as ut,t2 as se,qm as pt,t3 as ft,i3 as ht,oJ as Ce,jB as De,jb as mt,cG as gt,i6 as dt,t4 as oe,aU as xt,t5 as V,t6 as wt,t7 as yt,t8 as E,aE as vt,t9 as $t,ta as At,tb as bt,tc as St,td as Rt,te as Ft,tf as _t,f6 as ie,f5 as Lt}from"./index-etWHd6DB.js";import{u as ye,y as jt,h as Mt}from"./External-pI94N27Z.js";function Pt({xmin:e,xmax:t,ymin:n,ymax:r,zmin:s,zmax:i},o,l,c){s??(s=0),i??(i=0),ve??(ve=new Float64Array(24));const a=ve;return a[0]=e,a[1]=n,a[2]=s,a[3]=e,a[4]=r,a[5]=s,a[6]=t,a[7]=r,a[8]=s,a[9]=t,a[10]=n,a[11]=s,a[12]=e,a[13]=n,a[14]=i,a[15]=e,a[16]=r,a[17]=i,a[18]=t,a[19]=r,a[20]=i,a[21]=t,a[22]=n,a[23]=i,Le({positions:a,transform:o,vertexSpace:l,inSpatialReference:c,outSpatialReference:c,outPositions:a}),q(a,c)}let ve=null;function q(e,t){let n=1/0,r=1/0,s=1/0,i=-1/0,o=-1/0,l=-1/0;const c=e.length;let a=0;for(;a<c;){const u=e[a++],p=e[a++],f=e[a++];n=Math.min(n,u),r=Math.min(r,p),s=Math.min(s,f),i=Math.max(i,u),o=Math.max(o,p),l=Math.max(l,f)}return new je({xmin:n,ymin:r,zmin:s,xmax:i,ymax:o,zmax:l,spatialReference:t})}const Z="esri.geometry.support.meshUtils.centerAt";function Ot(e,t,n){var i;if(!((i=e.vertexAttributes)!=null&&i.position))return;const{vertexSpace:r}=e,s=(n==null?void 0:n.origin)??e.origin;r.isRelative?(te(r,Z,n),Et(e,t,s)):ne(e.spatialReference,n)?kt(e,t,s):zt(e,t,s)}function Et(e,t,n){const{vertexSpace:r}=e;if(!r.isRelative)return;const s=Ue,i=Te;if(!S(t,i,e.spatialReference))return void d.getLogger(Z).error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`);if(!S(n,s,e.spatialReference)){const c=e.origin;s[0]=c.x,s[1]=c.y,s[2]=c.z,d.getLogger(Z).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}const o=W(Dt,i,s),l=r.origin;r.origin=re(w(),l,o)}function kt(e,t,n){const r=Xe(e.vertexAttributes,n,{geographic:!0}),{position:s,normal:i,tangent:o}=Ye(r,t,{geographic:!0});e.vertexAttributes.position=s,e.vertexAttributes.normal=i,e.vertexAttributes.tangent=o,e.vertexAttributesChanged()}function zt(e,t,n){const r=Ue,s=Te;if(S(t,s,e.spatialReference)){if(!S(n,r,e.spatialReference)){const i=e.origin;r[0]=i.x,r[1]=i.y,r[2]=i.z,d.getLogger(Z).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}Ct(e.vertexAttributes.position,s,r),e.vertexAttributesChanged()}else d.getLogger(Z).error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}function Ct(e,t,n){if(e)for(let r=0;r<e.length;r+=3)for(let s=0;s<3;s++)e[r+s]+=t[s]-n[s]}const Te=w(),Ue=w(),Dt=w();async function Tt(e,t,n){const{source:r}=t,{loadGLTFMesh:s}=await Me(H(()=>import("./loadGLTFMesh-mrSaTlNw.js"),__vite__mapDeps([0,1,2])),n),i=await It(r,n);le(n);const o=s(new L({x:0,y:0,z:0,spatialReference:e.spatialReference}),i.url,{resolveFile:Ut(i),requestFile:void 0,useTransform:!0,signal:n==null?void 0:n.signal,expectedType:i.type});o.then(()=>i.dispose(),()=>i.dispose());const{vertexAttributes:l,components:c}=await o;e.vertexAttributes=l,e.components=c}function Ut(e){const t=et(e.url);return n=>{const r=tt(n,t,t),s=r?r.replace(/^ *\.\//,""):null;return(s?e.files.get(s):null)??n}}async function It(e,t){if(Array.isArray(e)){if(!e.length)throw new ce("mesh-load-external:missing-assets","There must be at least one file to load");return e[0]instanceof File?Vt(e):Gt(e,t)}return Ie(e)}async function Bt(e,t){const{parts:n,assetMimeType:r,assetName:s}=e;if(n.length===1)return new Y(n[0].partUrl);const i=await e.toBlob(t);return le(t),Y.fromBlob(i,Ne(s,r))}function Ie(e){return Y.fromBlob(e,Ne(e.name,e.type))}function Vt(e){return Ge(e.map(t=>({name:t.name,mimeType:t.type,source:Ie(t)})))}async function Gt(e,t){const n=await nt(e.map(async r=>{const s=await Bt(r);return le(t),{name:r.assetName,mimeType:r.assetMimeType,source:s}}));if(rt(t))throw n.forEach(r=>r.source.dispose()),st();return Ge(n)}const Be=/^model\/gltf\+json$/,Ve=/^model\/gltf-binary$/,ae=/\.gltf$/i,Wt=/\.glb$/i;function Ge(e){const t=new Map;let n,r=null;for(const{name:s,mimeType:i,source:o}of e)r===null&&(Be.test(i)||ae.test(s)?(r=o.url,n="gltf"):(Ve.test(i)||Wt.test(s))&&(r=o.url,n="glb")),t.set(s,o.url),o.files.forEach((l,c)=>t.set(c,l));if(r==null)throw new ce("mesh-load-external:missing-files","Missing files to load external mesh source");return new Y(r,()=>e.forEach(({source:s})=>s.dispose()),t,n)}let Y=class We{constructor(t,n=()=>{},r=new Map,s){this.url=t,this.dispose=n,this.files=r,this.type=s}static fromBlob(t,n){const r=URL.createObjectURL(t);return new We(r,()=>URL.revokeObjectURL(r),void 0,n)}};function Ne(e,t){return Be.test(t)||ae.test(e)?"gltf":Ve.test(t)||ae.test(e)?"glb":void 0}let M=class extends ot{constructor(){super(),this.externalSources=new it,this._explicitDisplaySource=null,this.addHandles(at(()=>this.externalSources,"after-remove",({item:e})=>{e===this._explicitDisplaySource&&(this._explicitDisplaySource=null)},{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(e){if(e!=null&&!ye(e))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=e,e&&this.externalSources.every(t=>!jt(t,e))&&this.externalSources.add(e)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(e){return this.externalSources.items.filter(t=>Mt(t,e))}get _implicitDisplaySource(){return this.externalSources.find(ye)}};g([x()],M.prototype,"externalSources",void 0),g([x()],M.prototype,"displaySource",null),g([x()],M.prototype,"_implicitDisplaySource",null),g([x()],M.prototype,"_explicitDisplaySource",void 0),M=g([Pe("esri.geometry.support.meshUtils.Metadata")],M);const Nt="esri.geometry.support.meshUtils.offset";function Zt(e,t,n){var s;if(!((s=e.vertexAttributes)!=null&&s.position))return;const{vertexSpace:r}=e;r.isRelative?(te(r,Nt,n),Jt(r,t)):ne(e.spatialReference,n)?Kt(e,t):qt(e,t)}function Jt(e,t){const n=e.origin;e.origin=re(w(),n,t)}function Kt(e,t){const n=e.spatialReference,r=e.vertexAttributes.position,s=e.vertexAttributes.normal,i=e.vertexAttributes.tangent,o=new Float64Array(r.length),l=s!=null?new Float32Array(s.length):null,c=i!=null?new Float32Array(i.length):null,a=e.extent.center,u=Ht;Oe(n,[a.x,a.y,a.z],$e,ue(n)),Ee(Ae,$e),Q(u,t,Ae),pe(r,n,o),s!=null&&l!=null&&fe(s,r,o,n,l),i!=null&&c!=null&&he(i,r,o,n,c),Ze(o,u),me(o,r,n),s!=null&&l!=null&&ge(l,r,o,n,s),i!=null&&c!=null&&de(c,r,o,n,i),e.vertexAttributesChanged()}function qt(e,t){Ze(e.vertexAttributes.position,t),e.vertexAttributesChanged()}function Ze(e,t){if(e)for(let n=0;n<e.length;n+=3)for(let r=0;r<3;r++)e[n+r]+=t[r]}const Ht=w(),$e=ke(),Ae=xe();function Qt(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=on,r=4*e.length,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),l=new Uint32Array(2*e.length*3);let c=0,a=0,u=0,p=0;for(let f=0;f<e.length;f++){const h=e[f],R=c/3;for(const A of t)l[p++]=R+A;const B=h.corners;for(let A=0;A<4;A++){const P=B[A];let $=0;o[u++]=.25*n[A][0]+h.uvOrigin[0],o[u++]=h.uvOrigin[1]-.25*n[A][1];for(let b=0;b<3;b++)h.axis[b]!==0?(s[c++]=.5*h.axis[b],i[a++]=h.axis[b]):(s[c++]=.5*P[$++],i[a++]=0)}}return{position:s,normal:i,uv:o,faces:l}}function Xt(e,t){const n=e.components[0],r=n.faces,s=an[t],i=6*s,o=new Array(6),l=new Array(r.length-6);let c=0,a=0;for(let u=0;u<r.length;u++)u>=i&&u<i+6?o[c++]=r[u]:l[a++]=r[u];if(e.vertexAttributes.uv!=null){const u=new Float32Array(e.vertexAttributes.uv),p=4*s*2,f=[0,1,1,1,1,0,0,0];for(let h=0;h<f.length;h++)u[p+h]=f[h];e.vertexAttributes.uv=u}return e.components=[new I({faces:o,material:n.material}),new I({faces:l})],e}function Yt(e=0){const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),l=new Uint32Array(3*((t-1)*n*2));let c=0,a=0,u=0,p=0;for(let f=0;f<=t;f++){const h=f/t*Math.PI+.5*Math.PI,R=Math.cos(h),B=Math.sin(h);m[2]=B;const A=f===0||f===t,P=A?n-1:n;for(let $=0;$<=P;$++){const b=$/P*2*Math.PI;m[0]=-Math.sin(b)*R,m[1]=Math.cos(b)*R;for(let F=0;F<3;F++)s[c]=.5*m[F],i[c]=m[F],++c;o[a++]=($+(A?.5:0))/n,o[a++]=f/t,f!==0&&$!==n&&(f!==t&&(l[u++]=p,l[u++]=p+1,l[u++]=p-n),f!==1&&(l[u++]=p,l[u++]=p-n,l[u++]=p-n-1)),p++}}return{position:s,normal:i,uv:o,faces:l}}function en(e=0){const n=Math.round(16*2**e),r=4*(n+1)+2*n,s=new Float64Array(3*r),i=new Float32Array(3*r),o=new Float32Array(2*r),l=new Uint32Array(3*(4*n));let c=0,a=0,u=0,p=0,f=0;for(let h=0;h<=5;h++){const R=h===0||h===5,B=h<=1||h>=4,A=h===2||h===4,P=R?n-1:n;for(let $=0;$<=P;$++){const b=$/P*2*Math.PI,F=R?0:.5;m[0]=F*Math.sin(b),m[1]=F*-Math.cos(b),m[2]=h<=2?.5:-.5;for(let O=0;O<3;O++)s[c++]=m[O],i[a++]=B?O===2?h<=1?1:-1:0:O===2?0:m[O]/F;o[u++]=($+(R?.5:0))/n,o[u++]=h<=1?1*h/3:h<=3?1*(h-2)/3+1/3:1*(h-4)/3+2/3,A||h===0||$===n||(h!==5&&(l[p++]=f,l[p++]=f+1,l[p++]=f-n),h!==1&&(l[p++]=f,l[p++]=f-n,l[p++]=f-n-1)),f++}}return{position:s,normal:i,uv:o,faces:l}}function tn(e,t){const n=typeof t=="number"?t:t!=null?t.width:1,r=typeof t=="number"?t:t!=null?t.height:1;switch(e){case"up":case"down":return{width:n,depth:r};case"north":case"south":return{width:n,height:r};case"east":case"west":return{depth:n,height:r}}}function nn(e){const t=G.facingAxisOrderSwap[e],n=G.position,r=G.normal,s=new Float64Array(n.length),i=new Float32Array(r.length);let o=0;for(let l=0;l<4;l++){const c=o;for(let a=0;a<3;a++){const u=t[a],p=Math.abs(u)-1,f=u>=0?1:-1;s[o]=n[c+p]*f,i[o]=r[c+p]*f,o++}}return{position:s,normal:i,uv:new Float32Array(G.uv),faces:new Uint32Array(G.faces),isPlane:!0}}const k=1,z=2,C=3,G={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[C,k,z],west:[-C,-k,z],north:[-k,C,z],south:[k,-C,z],up:[k,z,C],down:[k,-z,-C]}};function J(e,t,n){e.isPlane||rn(e),sn(e,n==null?void 0:n.size);const{vertexAttributes:r,vertexSpace:s,transform:i}=lt(e,t,n);return{vertexAttributes:new X({...r,uv:e.uv}),vertexSpace:s,transform:i,components:[new I({faces:e.faces,material:(n==null?void 0:n.material)||null})],spatialReference:t.spatialReference}}function rn(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}function sn(e,t){if(t==null)return;const n=typeof t=="number"?[t,t,t]:[t.width!=null?t.width:1,t.depth!=null?t.depth:1,t.height!=null?t.height:1];_[0]=n[0],_[4]=n[1],_[8]=n[2];for(let r=0;r<e.position.length;r+=3){for(let s=0;s<3;s++)m[s]=e.position[r+s];Q(m,m,_);for(let s=0;s<3;s++)e.position[r+s]=m[s]}if(n[0]!==n[1]||n[1]!==n[2]){_[0]=1/n[0],_[4]=1/n[1],_[8]=1/n[2];for(let r=0;r<e.normal.length;r+=3){for(let s=0;s<3;s++)m[s]=e.normal[r+s];Q(m,m,_),ct(m,m);for(let s=0;s<3;s++)e.normal[r+s]=m[s]}}}const on={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},an={south:0,east:1,north:2,west:3,up:4,down:5},m=w(),_=xe(),Je="esri.geometry.support.meshUtils.rotate";function ln(e,t,n){var i;if(!((i=e.vertexAttributes)!=null&&i.position)||t[3]===0)return;const{spatialReference:r,vertexSpace:s}=e;if(s.isRelative){te(s,Je,n);const o=(n==null?void 0:n.origin)??e.origin;e.transform??(e.transform=new N),cn(e.transform,s,t,o)}else{const o=(n==null?void 0:n.origin)??e.origin;ne(r,n)?un(e,t,o):pn(e,t,o)}}function cn(e,t,n,r){const s=t.origin,i=ze(D,r.x,r.y,r.z??0),o=W(D,i,s);e.applyLocalInverse(o,be),e.rotation=ut(e.rotation,n,we()),e.applyLocalInverse(o,o),W(o,o,be),e.translation=re(w(),e.translation,o)}function un(e,t,n){const r=e.spatialReference,s=ue(r),i=Ke;S(n,i,s)||S(e.origin,i,s);const o=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,a=new Float64Array(o.length),u=l!=null?new Float32Array(l.length):null,p=c!=null?new Float32Array(c.length):null;Oe(s,i,ee,s),Ee(Re,ee);const f=Se;Q(se(Se),se(t),Re),f[3]=t[3],pe(o,r,a),l!=null&&u!=null&&fe(l,o,a,r,u),c!=null&&p!=null&&he(c,o,a,r,p),U(a,f,3,i),me(a,o,r),l!=null&&u!=null&&(U(u,f,3),ge(u,o,a,r,l)),c!=null&&p!=null&&(U(p,f,4),de(p,o,a,r,c)),e.vertexAttributesChanged()}function pn(e,t,n){const r=Ke;if(!S(n,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,d.getLogger(Je).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}U(e.vertexAttributes.position,t,3,r),U(e.vertexAttributes.normal,t,3),U(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}function U(e,t,n,r=Ce){if(e!=null){pt(ee,ft(t),se(t));for(let s=0;s<e.length;s+=n){for(let i=0;i<3;i++)D[i]=e[s+i]-r[i];ht(D,D,ee);for(let i=0;i<3;i++)e[s+i]=D[i]+r[i]}}}const D=w(),be=w(),Se=we(),ee=ke(),Re=xe(),Ke=w(),qe="esri.geometry.support.meshUtils.scale";function fn(e,t,n){var i;if(!((i=e.vertexAttributes)!=null&&i.position))return;const{spatialReference:r,vertexSpace:s}=e;if(s.isRelative){te(s,qe,n);const o=(n==null?void 0:n.origin)??e.origin;e.transform??(e.transform=new N),hn(e.transform,s,t,o)}else{const o=ne(r,n),l=(n==null?void 0:n.origin)??e.origin;o?mn(e,t,l):gn(e,t,l)}}function hn(e,t,n,r){const s=t.origin,i=ze(T,r.x,r.y,r.z),o=W(T,i,s);e.applyLocalInverse(o,Fe);const l=De(w(),e.scale,n);e.scale=l,e.applyLocalInverse(o,o),W(o,o,Fe),e.translation=re(w(),e.translation,o)}function mn(e,t,n){const r=e.spatialReference,s=ue(r),i=Qe;S(n,i,s)||S(e.origin,i,s);const o=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,a=new Float64Array(o.length),u=l!=null?new Float32Array(l.length):null,p=c!=null?new Float32Array(c.length):null;pe(o,r,a),l!=null&&u!=null&&fe(l,o,a,r,u),c!=null&&p!=null&&he(c,o,a,r,p),He(a,t,i),me(a,o,r),l!=null&&u!=null&&ge(u,o,a,r,l),c!=null&&p!=null&&de(p,o,a,r,c),e.vertexAttributesChanged()}function gn(e,t,n){const r=Qe;if(!S(n,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,d.getLogger(qe).error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}). Projection may be possible after calling projection.load().`)}He(e.vertexAttributes.position,t,r),e.vertexAttributesChanged()}function He(e,t,n=Ce){if(e)for(let r=0;r<e.length;r+=3){for(let s=0;s<3;s++)T[s]=e[r+s]-n[s];De(T,T,t);for(let s=0;s<3;s++)e[r+s]=T[s]+n[s]}}const T=w(),Fe=w(),Qe=w();async function dn(e){const t=[];for(const n of e)n.name.toLowerCase().endsWith(".zip")?t.push(xn(n)):t.push(Promise.resolve(n));return(await Promise.all(t)).flat()}async function xn(e){const{BlobReader:t,ZipReader:n,BlobWriter:r}=await H(()=>import("./zipjs-wrapper-CX4-i-fs.js"),__vite__mapDeps([])),s=[];return(await new n(new t(e)).getEntries()).forEach(o=>{var a;if(o.directory||/^__MACOS/i.test(o.filename))return;const l=new r,c=(a=o.getData)==null?void 0:a.call(o,l).then(u=>new File([u],o.filename));c&&s.push(c)}),Promise.all(s)}var v;const j="esri.geometry.Mesh",wn={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:oe,"georeferenced-relative":Lt,local:ie}};let y=v=class extends mt.LoadableMixin(gt(dt)){constructor(e){super(e),this.components=null,this.vertexSpace=new oe,this.transform=null,this.metadata=new M,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new X,this.type="mesh"}initialize(){(this.metadata.externalSources.length===0||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.addHandles(xt(()=>{var e;return{vertexAttributes:this.vertexAttributes,components:(e=this.components)==null?void 0:e.map(t=>t.clone())}},()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){var e;return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):((e=this.metadata.displaySource)==null?void 0:e.extent)!=null}get _transformedExtent(){const{components:e,spatialReference:t,vertexAttributes:n,vertexSpace:r}=this,s=n.position;if(s.length===0||e&&e.length===0)return new je({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t});if(r.type==="local"){const{_untransformedExtent:i,transform:o}=this;return Pt(i,o,r,t)}if(r.type==="georeferenced-relative"){const{transform:i}=this,o=Le({positions:s,transform:i,vertexSpace:r,inSpatialReference:t,outSpatialReference:t});return q(o,t)}return q(s,t)}get _untransformedExtent(){return q(this.vertexAttributes.position,this.spatialReference)}get anchor(){const{vertexSpace:e}=this;if(e.isRelative)return e.getOriginPoint(this.spatialReference);const{center:t,zmin:n}=this._transformedExtent;return new L({x:t.x,y:t.y,z:n,spatialReference:this.spatialReference})}get origin(){const{vertexSpace:e}=this;return e.isRelative?e.getOriginPoint(this.spatialReference):this._transformedExtent.center}get extent(){var e,t;return this.loaded||((t=(e=this.metadata)==null?void 0:e.displaySource)==null?void 0:t.extent)==null?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){if(!this.loaded)return d.getLogger(this).error("addComponent()",new V().message);this.components||(this.components=[]),this.components.push(I.from(e)),this.notifyChange("components")}removeComponent(e){if(!this.loaded)return d.getLogger(this).error("removeComponent()",new V().message);if(this.components){const t=this.components.indexOf(e);if(t!==-1)return this.components.splice(t,1),void this.notifyChange("components")}d.getLogger(this).error("removeComponent()",new wt().message)}rotate(e,t,n,r){return yt(e,t,n,_e),ln(this,_e,r),this}offset(e,t,n,r){return this.loaded?(K[0]=e,K[1]=t,K[2]=n,Zt(this,K,r),this):(d.getLogger(this).error("offset()",new V().message),this)}scale(e,t){return this.loaded?(fn(this,e,t),this):(d.getLogger(this).error("scale()",new V().message),this)}centerAt(e,t){return this.loaded?(Ot(this,e,t),this):(d.getLogger(this).error("centerAt()",new V().message),this)}load(e){const{metadata:{displaySource:t}}=this;return t&&this.addResolvingPromise(Tt(this,t,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(){return this.cloneWithVertexSpace(this.vertexSpace.clone())}cloneWithVertexSpace(e){var r;let t=null;if(this.components){const s=new Map,i=new Map;t=this.components.map(o=>o.cloneWithDeduplication(s,i))}const n={components:t,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),vertexSpace:e,transform:((r=this.transform)==null?void 0:r.clone())??null,metadata:this.metadata.clone()};return new v(n)}cloneShallow(){return new v({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const t=H(()=>import("./gltfexport-Pfz6llQo.js"),__vite__mapDeps([3,1,2,4])),n=this.load(),r=await Promise.all([t,n]),{toBinaryGLTF:s}=r[0];return s(this,e)}get memoryUsage(){let e=0;if(e+=this.vertexAttributes.memoryUsage,this.components!=null)for(const t of this.components)e+=t.memoryUsage;return e}_clearSources(){this.metadata.clearSources()}static createBox(e,t){if(!(e instanceof L))return d.getLogger(j).error(".createBox()",new E().message),null;const n=new v(J(Qt(),e,t));return t!=null&&t.imageFace&&t.imageFace!=="all"?Xt(n,t.imageFace):n}static createSphere(e,t){return e instanceof L?new v(J(Yt((t==null?void 0:t.densificationFactor)||0),e,t)):(d.getLogger(j).error(".createSphere()",new E().message),null)}static createCylinder(e,t){return e instanceof L?new v(J(en((t==null?void 0:t.densificationFactor)||0),e,t)):(d.getLogger(j).error(".createCylinder()",new E().message),null)}static createPlane(e,t){if(!(e instanceof L))return d.getLogger(j).error(".createPlane()",new E().message),null;const n=(t==null?void 0:t.facing)??"up",r=tn(n,t==null?void 0:t.size);return new v(J(nn(n),e,{...t,size:r}))}static createFromPolygon(e,t){if(!(e instanceof vt))return d.getLogger(j).error(".createFromPolygon()",new $t().message),null;const n=At(e);return new v({vertexAttributes:new X({position:n.position}),components:[new I({faces:n.faces,shading:"flat",material:(t==null?void 0:t.material)??null})],spatialReference:e.spatialReference,vertexSpace:new oe})}static async createFromGLTF(e,t,n){if(!(e instanceof L)){const s=new E;throw d.getLogger(j).error(".createfromGLTF()",s.message),s}const{loadGLTFMesh:r}=await Me(H(()=>import("./loadGLTFMesh-mrSaTlNw.js"),__vite__mapDeps([0,1,2])),n);return new v(await r(e,t,n))}static async createFromFiles(e,t,n){const r=a=>d.getLogger(j).error(".createFromFiles()",a.message);if(!(e instanceof L)){const a=new E;throw r(a),a}const s=n==null?void 0:n.layer;if(!s){const a=new bt;throw r(a),a}const i=await v.extractAndFilterFiles(t,s),o=i.reduce((a,u)=>St(s.infoFor3D,u)?a+1:a,0);if(o===0){const a=new Rt;throw r(a),a}if(o>1){const a=new Ft;throw r(a),a}const l=v.createWithExternalSource(e,i),[c]=await s.uploadAssets([l],n);return c}static async extractAndFilterFiles(e,t){const n=t==null?void 0:t.infoFor3D;return n?(await dn(e)).filter(r=>_t(n,r)):e}static createWithExternalSource(e,t,n){var f;const r=(n==null?void 0:n.extent)??null,{x:s,y:i,z:o,spatialReference:l}=e,c=((f=n==null?void 0:n.transform)==null?void 0:f.clone())??new N,a=(n==null?void 0:n.vertexSpace)??new ie({origin:[s,i,o??0]}),u={source:t,extent:r},p=new M;return p.externalSources.push(u),new v({metadata:p,transform:c,vertexSpace:a,spatialReference:l})}static createIncomplete(e,t){var a;const{x:n,y:r,z:s,spatialReference:i}=e,o=((a=t==null?void 0:t.transform)==null?void 0:a.clone())??new N,l=(t==null?void 0:t.vertexSpace)??new ie({origin:[n,r,s??0]}),c=new v({transform:o,vertexSpace:l,spatialReference:i});return c.addResolvingPromise(Promise.reject(new ce("mesh-incomplete","Mesh resources are not complete"))),c}};g([x({type:[I],json:{write:!0}})],y.prototype,"components",void 0),g([x({nonNullable:!0,types:wn,constructOnly:!0,json:{write:!0}})],y.prototype,"vertexSpace",void 0),g([x({type:N,json:{write:!0}})],y.prototype,"transform",void 0),g([x({constructOnly:!0})],y.prototype,"metadata",void 0),g([x()],y.prototype,"hasExtent",null),g([x()],y.prototype,"_transformedExtent",null),g([x()],y.prototype,"_untransformedExtent",null),g([x()],y.prototype,"anchor",null),g([x()],y.prototype,"origin",null),g([x({readOnly:!0,json:{read:!1}})],y.prototype,"extent",null),g([x({readOnly:!0,json:{read:!1,write:!0,default:!0}})],y.prototype,"hasZ",void 0),g([x({readOnly:!0,json:{read:!1,write:!0,default:!1}})],y.prototype,"hasM",void 0),g([x({type:X,nonNullable:!0,json:{write:!0}})],y.prototype,"vertexAttributes",void 0),y=v=g([Pe(j)],y);const K=w(),_e=we(),$n=y;export{$n as default};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = ["assets/loadGLTFMesh-mrSaTlNw.js","assets/index-etWHd6DB.js","assets/index-2jScoq2u.css","assets/gltfexport-Pfz6llQo.js","assets/imageutils-XK-sO1hY.js"]
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i])
}